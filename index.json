[{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/overview.html#1-1","title":"Overview","content":" You want to configure your factories?  You want to reduce your factory boilerplate code?  You want to check automatically for mandatory options or merge default options?  You want to have a valid config structure?  You want to generate your configuration files from factory classes?  This library comes to the rescue!  intop-config provides interfaces and a concrete implementation to create instances depending on configuration via factory classes and ensures a valid config structure. It can also be used to auto discover factories and to create configuration files. Well tested. Besides unit test and continuous integration\/inspection this solution is also ready for production use. Framework agnostic This PHP library does not depends on any framework but you can use it with your favourite framework. Every change is tracked. Want to know whats new? Take a look at the changelog section. Listen to your ideas. Have a great idea? Bring your tested pull request or open a new issue. See contributing section. You should have coding conventions and you should have config conventions. If not, you should think about that. interop-config is universally applicable! See further documentation for more details."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/overview.html#1-1-1","title":"Installation","content":"The suggested installation method is via composer. For composer documentation, please refer to getcomposer.org.Run composer require sandrokeil\/interop-config to install interop-config.It is recommended to use psr-11 to retrieve the configuration in your factories."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/overview.html#1-1-2","title":"Config Structure","content":" The following example is a common practice for libraries. You are free to use another config structure. See examples. The config keys should have the following structure vendor.package.container_id. The container_id is optional and is only necessary if you have different instances of the same class e.g. database connection.A common configuration looks like that:\/\/ interop config example return [ \/\/ vendor name 'doctrine' =&gt; [ \/\/ package name 'connection' =&gt; [ \/\/ container id 'orm_default' =&gt; [ \/\/ mandatory options 'driverClass' =&gt; 'Doctrine\\DBAL\\Driver\\PDOMySql\\Driver', 'params' =&gt; [ 'host' =&gt; 'localhost', 'port' =&gt; '3306', 'user' =&gt; 'username', 'password' =&gt; 'password', 'dbname' =&gt; 'database', ], ], ], ], ]; So doctrine is the vendor, connection is the package and orm_default is the container id. After that the specified instance options follow. The following example uses ConfigurationTrait which implements the logic to retrieve the options from a configuration. RequiresConfigId interface ensures support for more than one instance. Note that the configuration above is injected as $config in options() and psr-11 is used to retrieve the application configuration. use Interop\\Config\\ConfigurationTrait; use Interop\\Config\\RequiresConfigId; use Interop\\Config\\RequiresMandatoryOptions; use Psr\\Container\\ContainerInterface; class MyDBALConnectionFactory implements RequiresConfigId, RequiresMandatoryOptions { use ConfigurationTrait; public function __invoke(ContainerInterface $container) { \/\/ get options for doctrine.connection.orm_default $options = $this-&gt;options($container-&gt;get('config'), 'orm_default'); \/\/ mandatory options check is automatically done by RequiresMandatoryOptions $driverClass = $options['driverClass']; $params = $options['params']; \/\/ create your instance and set options return $instance; } \/** * Is used to retrieve options from the configuration array ['doctrine' =&gt; ['connection' =&gt; []]]. * * @return iterable *\/ public function dimensions() : iterable { return ['doctrine', 'connection']; } \/** * Returns a list of mandatory options which must be available * * @return iterable List with mandatory options *\/ public function mandatoryOptions() : iterable { return ['params' =&gt; ['user', 'password', 'dbname']]; } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2","title":"Quick Start","content":"Typically you will have a factory which creates a concrete instance depending on some options (dependencies)."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-1","title":"RequiresConfig interface","content":"Let's say My factory requires a configuration so you will implement the RequiresConfig interface.use Interop\\Config\\RequiresConfig; class MyAwesomeFactory implements RequiresConfig { public function dimensions() : iterable { return ['vendor-package']; } public function canRetrieveOptions($config) : bool { \/\/ custom implementation depending on specifications } public function options($config) { \/\/ custom implementation depending on specifications } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-1-1","title":"Need configuration per container id","content":"If you support more than one instance with different configuration then you simply use the RequiresConfigId interface. Don't use the dimensions() method for container id configuration use Interop\\Config\\RequiresConfigId; class MyAwesomeFactory implements RequiresConfigId { public function dimensions() : iterable { return ['vendor-package']; } public function canRetrieveOptions($config, string $configId = null) : bool { \/\/ custom implementation depending on specifications } public function options($config, string $configId = null) { \/\/ custom implementation depending on specifications } } Ok you have now a factory which says that the factory supports a configuration and you have a PHP file which contains the configuration as a PHP array, but how is the configuration used?Depending on the implemented interface RequiresConfigId above our configuration PHP file looks like that:\/\/ interop config example return [ \/\/ vendor\/package name 'vendor-package' =&gt; [ \/\/ container id 'container-id' =&gt; [ \/\/ some options ... ], ], ]; As you can see that you have to implement the functionality of canRetrieveOptions() and options() method. Good news, this is not necessary. See ConfigurationTrait."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-2","title":"ConfigurationTrait","content":"The ConfigurationTrait is a concrete implementation of the RequiresConfig interface and has full support of ProvidesDefaultOptions, RequiresMandatoryOptions and RequiresConfigIdinterfaces. It's a PHP Trait so you can extend your factory from a class.Your factory looks now like that:use Interop\\Config\\RequiresConfigId; use Interop\\Config\\ConfigurationTrait; class MyAwesomeFactory implements RequiresConfigId { use ConfigurationTrait; public function dimensions() : iterable { return ['vendor-package']; } } Now you have all the ingredients to create multiple different instances depending on configuration."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-3","title":"Create an instance","content":"Factories are often implemented as a callable. This means that your factory instance can be called like a function. You can also use a create method or something else.The factory gets a ContainerInterface (Container PSR) provided to retrieve the configuration. Note that the configuration above is injected as $config in options() and psr-11 is used to retrieve the application configuration. use Interop\\Config\\RequiresConfigId; use Interop\\Config\\ConfigurationTrait; use Psr\\Container\\ContainerInterface; class MyAwesomeFactory implements RequiresConfigId { use ConfigurationTrait; public function dimensions() : iterable { return ['vendor-package']; } public function __invoke(ContainerInterface $container) { \/\/ get options for vendor-package.container-id \/\/ method options() is implemented in ConfigurationTrait $options = $this-&gt;options($container-&gt;get('config'), 'orm_default'); return new Awesome($options); } } The ConfigurationTrait does the job to check and retrieve options depending on implemented interfaces. Nice, but what is if I have mandatory options? See RequiresMandatoryOptions interface."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-4","title":"RequiresMandatoryOptions interface","content":"The RequiresConfig::options() interface specification says that it MUST support mandatory options check. Let's say that we need params for a db connection. Our config should looks like that:\/\/ interop config example return [ \/\/ vendor\/package name 'vendor-package' =&gt; [ \/\/ container id 'container-id' =&gt; [ 'params' =&gt; [ 'user' =&gt; 'username', 'password' =&gt; 'password', 'dbname' =&gt; 'database', ], ], ], ]; Remember our factory sentence. My factory requires a configuration and requires a container id along with mandatory options. The ConfigurationTrait ensures that these options are available, otherwise an exception is thrown. This is great, because the developer gets an exact exception message with what is wrong. This is useful for developers who use your factory the first time.use Interop\\Config\\RequiresConfigId; use Interop\\Config\\RequiresMandatoryOptions; use Interop\\Config\\ConfigurationTrait; use Psr\\Container\\ContainerInterface; class MyAwesomeFactory implements RequiresConfigId, RequiresMandatoryOptions { use ConfigurationTrait; public function dimensions() : iterable { return ['vendor-package']; } public function mandatoryOptions() : iterable { return ['params' =&gt; ['user', 'password', 'dbname']]; } public function __invoke(ContainerInterface $container) { \/\/ get options for vendor-package.container-id \/\/ method options() is implemented in ConfigurationTrait \/\/ an exception is raised when a mandatory option is missing $options = $this-&gt;options($container-&gt;get('config'), 'container-id'); return new Awesome($options); } } Hey, the database port and host is missing. That's right, but the default value of the port is 3306 and the host is localhost. It makes no sense to set it in the configuration. So I make the database port\/host not configurable? No, you use the ProvidesDefaultOptions interface."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-5","title":"ProvidesDefaultOptions interface","content":"The ProvidesDefaultOptions interface defines default options for your instance. These options are merged with the provided options.Remember: My factory requires configuration, requires a container id along with mandatory options and it provides default options.use Interop\\Config\\RequiresConfigId; use Interop\\Config\\RequiresMandatoryOptions; use Interop\\Config\\ProvidesDefaultOptions; use Interop\\Config\\ConfigurationTrait; use Psr\\Container\\ContainerInterface; class MyAwesomeFactory implements RequiresConfigId, RequiresMandatoryOptions, ProvidesDefaultOptions { use ConfigurationTrait; public function dimensions() : iterable { return ['vendor-package']; } public function mandatoryOptions() : iterable { return ['params' =&gt; ['user', 'password', 'dbname']]; } public function defaultOptions() : iterable { return [ 'params' =&gt; [ 'host' =&gt; 'localhost', 'port' =&gt; '3306', ], ]; } public function __invoke(ContainerInterface $container) { \/\/ get options for vendor-package.container-id \/\/ method options() is implemented in ConfigurationTrait \/\/ an exception is raised when a mandatory option is missing \/\/ if host\/port is missing, default options will be used $options = $this-&gt;options($container-&gt;get('config'), 'container-id'); return new Awesome($options); } } Now you have a bullet proof factory class which throws meaningful exceptions if something goes wrong. This is cool, but I don't want to use exceptions. No problem, see next."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/getting-started\/quick-Start.html#1-2-6","title":"Avoid exceptions","content":"The RequiresConfig interface provides a method canRetrieveOptions(). This method checks if options are available depending on implemented interfaces and checks that the retrieved options are an array or have implemented \\ArrayAccess. canRetrieveOptions() returning true does not mean that options($config) will not throw an exception. It does however mean that options() will not throw an OptionNotFoundException. Mandatory options are not checked. You can call this function and if it returns false, you can use the default options.use Interop\\Config\\RequiresConfigId; use Interop\\Config\\RequiresMandatoryOptions; use Interop\\Config\\ProvidesDefaultOptions; use Interop\\Config\\ConfigurationTrait; use Psr\\Container\\ContainerInterface; class MyAwesomeFactory implements RequiresConfigId, RequiresMandatoryOptions, ProvidesDefaultOptions { use ConfigurationTrait; \/\/ other functions see above public function __invoke(ContainerInterface $container) { $config = $container-&gt;get('config'); $options = []; if ($this-&gt;canRetrieveOptions($config, 'container-id')) { \/\/ get options for vendor-package.container-id \/\/ method options() is implemented in ConfigurationTrait \/\/ if host\/port is missing, default options will be used $options = $this-&gt;options($config, 'container-id'); } elseif ($this instanceof ProvidesDefaultOptions) { $options = $this-&gt;defaultOptions(); } return new Awesome($options); } } Nice, is there a one-liner? Of course. You can use the optionsWithFallback() method. This function is not a part of the specification but is implemented in ConfigurationTrait to reduce some boilerplate code.use Interop\\Config\\RequiresConfigId; use Interop\\Config\\RequiresMandatoryOptions; use Interop\\Config\\ProvidesDefaultOptions; use Interop\\Config\\ConfigurationTrait; use Psr\\Container\\ContainerInterface; class MyAwesomeFactory implements RequiresConfigId, RequiresMandatoryOptions, ProvidesDefaultOptions { use ConfigurationTrait; \/\/ other functions see above public function __invoke(ContainerInterface $container) { \/\/ get options for vendor-package.container-id \/\/ method options() is implemented in ConfigurationTrait \/\/ if configuration is not available, default options will be used $options = $this-&gt;optionsWithFallback($container-&gt;get('config'), 'container-id'); return new Awesome($options); } } Using optionsWithFallback() method and the RequiresMandatoryOptions is ambiguous or? Yes, so it's up to you to implement the interfaces in a sense order.Take a look at the examples section for more use cases. interop-config is universally applicable."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1","title":"API","content":"This file describes the classes of this package. All interfaces can be combined. Don't panic, the interfaces are quite easy and the ConfigurationTrait, which is a concrete implementation, has full support of those interfaces. You need only one interface called RequiresConfig to start and then you can implement the others if they are needed. RequiresConfig Interface RequiresConfigId Interface RequiresMandatoryOptions Interface ProvidesDefaultOptions Interface "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-1","title":"RequiresConfig Interface","content":"The RequiresConfig interface exposes three methods: dimensions, canRetrieveOptions and options."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-1-1","title":"dimensions()","content":" public function dimensions() : iterable The dimensions method has no parameters and MUST return an array. The values (used as key names) of the array are used as the depth of the configuration to retrieve options. Two values means a configuration depth of two. An empty array is valid."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-1-2","title":"canRetrieveOptions()","content":" public function canRetrieveOptions($config) : bool Checks if options are available depending on provided dimensions and checks that the retrieved options are an array or have implemented \\ArrayAccess."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-1-3","title":"options()","content":" public function options($config) : [] The options method takes one mandatory parameter: a configuration array. It MUST be an array or an object which implements the ArrayAccess interface. A call to options returns the configuration depending on provided dimensions of the class or throws an exception if the parameter is invalid or if the configuration is missing or if a mandatory option is missing.If the ProvidesDefaultOptions interface is implemented, these options MUST be overridden by the provided config."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-1-3-1","title":"Exceptions","content":"Exceptions directly thrown by the options method MUST implement the Interop\\Config\\Exception\\ExceptionInterface.If the configuration parameter is not an array or not an object which implements the ArrayAccess interface the method SHOULD throw a Interop\\Config\\Exception\\InvalidArgumentException.If a key which is returned from dimensions is not set under the previous dimensions key in the configuration parameter, the method SHOULD throw a Interop\\Config\\Exception\\OptionNotFoundException.If a value from the configuration based on dimensions is not an array or an object which has \\ArrayAccess implemented, the method SHOULD throw a Interop\\Config\\Exception\\UnexpectedValueException.If the class implements the RequiresMandatoryOptions interface and if a mandatory option from mandatoryOptions is not set in the options array which was retrieved from the configuration parameter before, the method SHOULD throw a Interop\\Config\\Exception\\MandatoryOptionNotFoundException.If the retrieved options are not of type array or \\ArrayAccess the method SHOULD throw a Interop\\Config\\Exception\\UnexpectedValueException."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-2","title":"RequiresMandatoryOptions Interface","content":"The RequiresMandatoryOptions interface exposes one method: mandatoryOptions"},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-2-1","title":"mandatoryOptions()","content":" public function mandatoryOptions() : iterable The mandatoryOptions method has no parameters and MUST return an array of strings which represents the list of mandatory options. This array can have a multiple depth."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-3","title":"ProvidesDefaultOptions Interface","content":"The DefaultOptions interface exposes one method: defaultOptions"},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-3-1","title":"defaultOptions()","content":" public function defaultOptions() : iterable The defaultOptions method has no parameters and MUST return an key-value array where the key is the option name and the value is the default value for this option. This array can have a multiple depth. The return value MUST be compatible with the PHP function array_replace_recursive."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-4","title":"RequiresConfigId","content":"The RequiresConfigId is only a marker interface and has no methods. It marks the factory that multiple instances are supported. The ConfigurationTrait has an optional parameter $configId implemented for the methods of RequiresConfig. So it is full supported."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-5","title":"ConfigurationTrait","content":"The ConfigurationTrait implements the functions of RequiresConfig interface and has support for ProvidesDefaultOptions, RequiresMandatoryOptions and RequiresConfigId interfaces if the the class has they implemented.Additional it has one more method optionsWithFallback to reduce boilerplate code."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/api.html#2-1-5-1","title":"optionsWithFallback()","content":" public function optionsWithFallback($config) : [] Checks if options can be retrieved from config and if not, default options (ProvidesDefaultOptions interface) or an empty array will be returned."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/examples.html#2-2","title":"Examples","content":"This files contains examples for each interface. The factory class uses the ConfigurationTrait to retrieve options from a configuration and optional to perform a mandatory option check or merge default options. There is also an example for a independent config structure of the Zend Expressive TwigRendererFactory. The psr-11 specification is used, so it's framework agnostic."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/examples.html#2-2-1","title":"Use a vendor.package.id config structure","content":"Let's assume we have the following module configuration:\/\/ interop config example return [ \/\/ vendor name 'doctrine' =&gt; [ \/\/ package name 'connection' =&gt; [ \/\/ container id 'orm_default' =&gt; [ \/\/ mandatory params 'driverClass' =&gt; 'Doctrine\\DBAL\\Driver\\PDOMySql\\Driver', 'params' =&gt; [ 'host' =&gt; 'localhost', 'port' =&gt; '3306', 'user' =&gt; 'username', 'password' =&gt; 'password', 'dbname' =&gt; 'database', ], ], ], ], ];  Note that the configuration above is injected as $config in options() "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/examples.html#2-2-1-1","title":"Retrieving options","content":"Then you have easily access to the orm_default options in your method with ConfigurationTrait.use Interop\\Config\\ConfigurationTrait; use Interop\\Config\\RequiresConfigId; use Psr\\Container\\ContainerInterface; class MyDBALConnectionFactory implements RequiresConfigId { use ConfigurationTrait; public function __invoke(ContainerInterface $container) { \/\/ get options for doctrine.connection.orm_default $options = $this-&gt;options($container-&gt;get('config'), 'orm_default'); \/\/ check if mandatory options are available or use \\Interop\\Config\\RequiresMandatoryOptions, see below if (empty($options['driverClass'])) { throw new Exception\\RuntimeException( sprintf( 'Driver class was not set for configuration %s.%s.%s', 'doctrine', 'connection', 'orm_default' ) ); } if (empty($options['params'])) { throw new Exception\\RuntimeException( sprintf( 'Params was not set for configuration %s.%s.%s', 'doctrine', 'connection', 'orm_default' ) ); } $driverClass = $options['driverClass']; $params = $options['params']; \/\/ create your instance and set options return $instance; } \/** * Is used to retrieve options from the configuration array ['doctrine' =&gt; ['connection' =&gt; [...]]]. * * @return iterable *\/ public function dimensions() : iterable { return ['doctrine', 'connection']; } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/examples.html#2-2-1-2","title":"Mandatory options check","content":"You can also check for mandatory options automatically with MandatoryOptionsInterface. Now we want also check that option driverClass and params are available. So we also implement in the example above the interface RequiresMandatoryOptions. If one of these options are missing, an exception is raised.use Interop\\Config\\ConfigurationTrait; use Interop\\Config\\RequiresMandatoryOptions; use Interop\\Config\\RequiresConfigId; use Psr\\Container\\ContainerInterface; class MyDBALConnectionFactory implements RequiresConfigId, RequiresMandatoryOptions { use ConfigurationTrait; public function __invoke(ContainerInterface $container) { \/\/ get options for doctrine.connection.orm_default $options = $this-&gt;options($container-&gt;get('config'), 'orm_default'); \/\/ mandatory options check is automatically done by RequiresMandatoryOptions $driverClass = $options['driverClass']; $params = $options['params']; \/\/ create your instance and set options return $instance; } \/** * Returns a list of mandatory options which must be available * * @return string[] List with mandatory options *\/ public function mandatoryOptions() : iterable { return [ 'driverClass', 'params', ]; } \/** * Is used to retrieve options from the configuration array ['doctrine' =&gt; ['connection' =&gt; [...]]]. * * @return [] *\/ public function dimensions() : iterable { return ['doctrine', 'connection']; } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/examples.html#2-2-2","title":"Use a static factory","content":"Creation of a new instance of a specific config key is really easy by using the static variants of the factory. With this you don't have to instantiate a factory to use another config id in your config, which is really awesome. Remember, config files should only contain scalar values, so you can cache it in production. We have to add some lines of code to our factory. The magic is done via the __callStatic() method.use Interop\\Config\\ConfigurationTrait; use Interop\\Config\\RequiresMandatoryOptions; use Interop\\Config\\RequiresConfigId; use Psr\\Container\\ContainerInterface; class MyDBALConnectionFactory implements RequiresConfigId, RequiresMandatoryOptions { use ConfigurationTrait; \/** * @var string *\/ private $configId; \/** * Creates a new instance from a specified config, specifically meant to be used as static factory. * * In case you want to use another config key than provided by the factories, you can add the following factory to * your config: * * &lt;code&gt; * &lt;?php * return [ * 'doctrine.connection.orm_second' =&gt; [MyDBALConnectionFactory::class, 'orm_second'], * ]; * &lt;\/code&gt; * * @param string $name * @param array $arguments * @return mixed * @throws \\InvalidArgumentException *\/ public static function __callStatic($name, array $arguments) { if (!isset($arguments[0]) || !$arguments[0] instanceof ContainerInterface) { throw new \\InvalidArgumentException( sprintf('The first argument must be of type %s', ContainerInterface::class) ); } return (new static($name))-&gt;__invoke($arguments[0]); } \/** * @param string $configId *\/ public function __construct(string $configId) { $this-&gt;configId = $configId; } public function __invoke(ContainerInterface $container) { \/\/ get options for doctrine.connection.[config id] $options = $this-&gt;options($container-&gt;get('config'), $this-&gt;configId); \/\/ mandatory options check is automatically done by RequiresMandatoryOptions $driverClass = $options['driverClass']; $params = $options['params']; \/\/ create your instance and set options return $instance; } \/** * Returns a list of mandatory options which must be available * * @return iterable List with mandatory options *\/ public function mandatoryOptions() : iterable { return [ 'driverClass', 'params', ]; } \/** * Is used to retrieve options from the configuration array ['doctrine' =&gt; ['connection' =&gt; [...]]]. * * @return iterable *\/ public function dimensions() : iterable { return ['doctrine', 'connection']; } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/examples.html#2-2-2-1","title":"Default options","content":"Use the ProvidesDefaultOptions interface if you have default options. These options are merged with the provided options in \\Interop\\Config\\RequiresConfig::options(). Let's look at this example from DoctrineORMModule. All the options under the key orm_crawler are optional, but it's not visible in the factory.return [ 'doctrine' =&gt; [ 'configuration' =&gt; [ 'orm_crawler' =&gt; [ 'metadata_cache' =&gt; 'array', 'query_cache' =&gt; 'array', 'result_cache' =&gt; 'array', 'hydration_cache' =&gt; 'array', ], ], ], ]; use Interop\\Config\\ConfigurationTrait; use Interop\\Config\\ProvidesDefaultOptions; use Interop\\Config\\RequiresConfigId; class ConfigurationFactory implements RequiresConfigId, ProvidesDefaultOptions { use ConfigurationTrait; public function __invoke(ContainerInterface $container) { \/\/ get options for doctrine.configuration.orm_crawler $options = $this-&gt;options($container-&gt;get('config'), 'orm_crawler'); # these keys are always available now $options['metadata_cache']; $options['query_cache']; $options['result_cache']; $options['hydration_cache']; \/\/ create your instance and set options return $instance; } \/** * Returns a list of default options, which are merged in \\Interop\\Config\\RequiresConfig::options * * @return iterable List with default options and values *\/ public function defaultOptions() : iterable { return [ 'metadata_cache' =&gt; 'array', 'query_cache' =&gt; 'array', 'result_cache' =&gt; 'array', 'hydration_cache' =&gt; 'array', ]; } \/** * Is used to retrieve options from the configuration array * ['doctrine' =&gt; ['configuration' =&gt; []]]. * * @return iterable *\/ public function dimensions() : iterable { return ['doctrine', 'configuration']; } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/examples.html#2-2-3","title":"Use arbitrary configuration structure","content":"Whatever configuration structure you use, interop-config can handle it. You can use a three-dimensional array with vendor.package.id like the examples above or you don't care of it and organize your configuration by behavior or nature (db, cache, ... or sale, admin).The following example demonstrates how to replace the Zend Expressive TwigRendererFactory. The factory uses optionally the following config structure:return [ 'debug' =&gt; true, 'templates' =&gt; [ 'cache_dir' =&gt; 'path to cached templates', 'assets_url' =&gt; 'base URL for assets', 'assets_version' =&gt; 'base version for assets', 'extension' =&gt; 'file extension used by templates; defaults to html.twig', 'paths' =&gt; [ \/\/ namespace \/ path pairs \/\/ \/\/ Numeric namespaces imply the default\/main namespace. Paths may be \/\/ strings or arrays of string paths to associate with the namespace. ], ], 'twig' =&gt; [ 'cache_dir' =&gt; 'path to cached templates', 'assets_url' =&gt; 'base URL for assets', 'assets_version' =&gt; 'base version for assets', 'extensions' =&gt; [ \/\/ extension service names or instances ], ], ]; You can see that the factory uses different keys (debug, templates, twig) of the config array on the same level. This configuration is maybe used by other factories too like the debug setting. interop-config reduces the checks in the factory and gives the user the possibility to find out the config structure. More than that, it is possible to create the configuration file from the factory.namespace Zend\\Expressive\\Twig; use Psr\\Container\\ContainerInterface; use Twig_Environment as TwigEnvironment; use Twig_Extension_Debug as TwigExtensionDebug; use Twig_ExtensionInterface; use Twig_Loader_Filesystem as TwigLoader; use Zend\\Expressive\\Router\\RouterInterface; \/\/ interop-config use Interop\\Config\\ConfigurationTrait; use Interop\\Config\\RequiresConfig; use Interop\\Config\\ProvidesDefaultOptions; class TwigRendererFactory implements RequiresConfig, ProvidesDefaultOptions { use ConfigurationTrait; \/** * Uses root config to retrieve several options * * @return iterable *\/ public function dimensions() : iterable { return []; } \/** * This is the whole config structure with default settings for this factory *\/ public function defaultOptions() : iterable { return [ 'debug' =&gt; false, 'templates' =&gt; [ 'extension' =&gt; 'html.twig', 'paths' =&gt; [], ], 'twig' =&gt; [ 'cache_dir' =&gt; false, 'assets_url' =&gt; '', 'assets_version' =&gt; '', 'extensions' =&gt; [], ], ]; } \/** * @param ContainerInterface $container * @return TwigRenderer *\/ public function __invoke(ContainerInterface $container) { $config = $container-&gt;has('config') ? $container-&gt;get('config') : []; \/\/ no OptionNotFoundException is thrown from ConfigurationTrait, because there are no config dimensions $config = $this-&gt;options($config); $debug = (bool) $config['debug']; \/\/ Create the engine instance $loader = new TwigLoader(); $environment = new TwigEnvironment($loader, [ 'cache' =&gt; $debug ? false : $config['twig']['cache_dir'], 'debug' =&gt; $debug, 'strict_variables' =&gt; $debug, 'auto_reload' =&gt; $debug ]); \/\/ Add extensions if ($container-&gt;has(RouterInterface::class)) { $environment-&gt;addExtension(new TwigExtension( $container-&gt;get(RouterInterface::class), $config['twig']['assets_url'], $config['twig']['assets_version'] )); } if ($debug) { $environment-&gt;addExtension(new TwigExtensionDebug()); } \/\/ Add user defined extensions $this-&gt;injectExtensions($environment, $container, $config['twig']['extensions']); \/\/ Inject environment $twig = new TwigRenderer($environment, $config['templates']['extension']); \/\/ Add template paths foreach ($config['templates']['paths'] as $namespace =&gt; $paths) { $namespace = is_numeric($namespace) ? null : $namespace; foreach ((array) $paths as $path) { $twig-&gt;addPath($path, $namespace); } } return $twig; } \/** * Inject extensions into the TwigEnvironment instance. * * @param TwigEnvironment $environment * @param ContainerInterface $container * @param array $extensions * @throws Exception\\InvalidExtensionException *\/ private function injectExtensions(TwigEnvironment $environment, ContainerInterface $container, array $extensions) { foreach ($extensions as $extension) { \/\/ Load the extension from the container if (is_string($extension) &amp;&amp; $container-&gt;has($extension)) { $extension = $container-&gt;get($extension); } if (! $extension instanceof Twig_ExtensionInterface) { throw new Exception\\InvalidExtensionException(sprintf( 'Twig extension must be an instance of Twig_ExtensionInterface; \"%s\" given,', is_object($extension) ? get_class($extension) : gettype($extension) )); } if ($environment-&gt;hasExtension($extension-&gt;getName())) { continue; } $environment-&gt;addExtension($extension); } } \/\/ The mergeConfig function is not needed anymore \/\/ private function mergeConfig($config) } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/tutorial.html#2-3-1","title":"Overview","content":"In this short tutorial we will implement a simple example of interop-config. This example tries to give you a better understanding of what interop-config is and why you should use it."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/tutorial.html#2-3-1-1","title":"Components","content":"To implement interop-config we need a few components to glue it together. Configuration This file return an array with the configuration of our application ServiceLocator This class holds the root configuration of our application This class holds some plugin manager classes (invokables, factories, ...) ExampleFactory This class represent the factory for a simple component and implements some interfaces from interop-config "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/tutorial.html#2-3-1-2","title":"Folders","content":"We use the following simple folder structure for the example application:\u00e2\u0094\u0080\u00e2\u0094\u0080\u00e2\u0094\u0080 application_root\/ \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 composer.json \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 config\/ \u00e2\u0094\u0082\u00c2\u00a0\u00c2\u00a0 \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 main.php \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 public\/ \u00e2\u0094\u0082\u00c2\u00a0\u00c2\u00a0 \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 index.php \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 src\/ \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 SomVendorName\/ \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 Exception\/ \u00e2\u0094\u0082\u00c2\u00a0\u00c2\u00a0 \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 RuntimeException.php \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 MyComponent\/ \u00e2\u0094\u009c\u00e2\u0094\u0080\u00e2\u0094\u0080 MyComponentFactory.php \u00e2\u0094\u0094\u00e2\u0094\u0080\u00e2\u0094\u0080 MyFirstComponent.php "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/tutorial.html#2-3-2","title":"Install Composer and interop-config","content":"Since we have Composer it is really easy to manage our php packages. First of all we need Composer run. For that go to your application_root directory and setup a Composer.json file with the following listing.{ \"name\": \"test\", \"autoload\": { \"psr-4\": { \"SomeVendorName\\\\\": \"src\/\" } } } To use Composer we need to download the composer.phar from getcomposer.org. If you have installed Composer, you can get the PHP packages we setup in the composer.json via php composer.phar require sandrokeil\/interop-configIf you need more help look at getcomposer.org."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/tutorial.html#2-3-2-1","title":"Setup Composer autoloading","content":"Put the following code to the public\/index.php to get the class auto loading, so we do not have to include\/require classes before using them. \/\/ this makes our life easier, everything is relative to application root now chdir(dirname(__DIR__)); require 'vendor\/autoload.php'; \/\/ ... "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/tutorial.html#2-3-3","title":"Setup config and classes","content":"The following code is located in config\/main.php and holds the main configuration array of the project. return [ 'some_vendor_name' =&gt; [ 'my_component_configuration' =&gt; [ 'debug' =&gt; false, 'routes' =&gt; [ 'key1' =&gt; 'value1', 'key2' =&gt; 'value2', 'key3' =&gt; 'value3', ] ] ] ]; "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/tutorial.html#2-3-3-1","title":"ServiceLocator","content":"The ServiceLocator holds the application configuration and some plugin manager classes. The ServiceLocator is the main entry point if you need to instantiate classes in your application. namespace SomeVendorName; class ServiceLocator { \/** * Some factory classes * * @var array *\/ private $factories = array( 'config' =&gt; array(), 'my_component_factory' =&gt; 'SomeVendorName\\MyComponent\\MyComponentFactory' \/\/ ... ); public function __construct(array $config) { $this-&gt;factories['config'] = $config; } \/** * Get some simple factories * * @param $name * @return mixed *\/ public function get($name) { \/\/ return config simple if ($name === 'config' &amp;&amp; isset($this-&gt;factories['config'])) { return $this-&gt;factories['config']; } if (isset($this-&gt;factories[$name])) { $FactoryClass = new $this-&gt;factories[$name](); \/\/ if your factory implements a factory interface you should check it at this place return $FactoryClass-&gt;__invoke($this); } } \/** * Check if factory exists * * @param $name * @return bool *\/ public function has($name): bool { return isset($this-&gt;factories[$name]); } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/tutorial.html#2-3-3-2","title":"Runtime Exception","content":"To throw useful exceptions we have a RuntimeException in our namespace. There are many more exception types, but for this simple example we satisfied by the RuntimeException. The following code is located in src\/SomeVendorName\/Exception\/RuntimeException.php. namespace SomeVendorName\\Exception; class RuntimeException extends \\Exception { } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/tutorial.html#2-3-3-3","title":"The component factory class","content":"The factory class implements OptainOptions and uses the ConfigurationTrait. The factory class creates components with the configuration we explicitly setup before. Every component created by this factory will get the same configuration parameters. namespace SomeVendorName\\MyComponent; use SomeVendorName\\ServiceLocator; use SomeVendorName\\Exception\\RuntimeException; use SomeVendorName\\MyComponent\\MyFirstComponent; use Interop\\Config\\RequiresConfig; use Interop\\Config\\ConfigurationTrait; class MyComponentFactory implements ObtainsOptions { use ConfigurationTrait; public function dimensions(): iterable { return ['some_vendor_name', 'my_component_configuration']; } public function __invoke(ServiceLocator $ServiceLocator): MyFirstComponent { $options = $this-&gt;options($ServiceLocator-&gt;get('config')); \/\/ check if mandatory options are available or use \\Interop\\Config\\RequiresMandatoryOptions if (empty($options['routes'])) { throw new RuntimeException('routes not defined'); } if (empty($options['debug'])) { throw new RuntimeException('debug not defined'); } return new MyFirstComponent($options['routes'], $options['debug']); } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/tutorial.html#2-3-3-4","title":"The first component class","content":"Finally we have the component class where we need the configuration. namespace SomeVendorName\\MyComponent; use SomeVendorName\\Exception\\RuntimeException; class MyFirstComponent { public function __construct($routes, $debug){ var_dump(routes, debug); } } "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/tutorial.html#2-3-4","title":"Run the example application","content":"To run the example application we just need the following few lines in the public\/index.php: \/\/ this makes our life easier, everything is relative to application root now chdir(dirname(__DIR__)); require 'vendor\/autoload.php'; $ServiceLocator = new SomeVendorName\\ServiceLocator('config\/main.php'); $MyComponentFactory = $ServiceLocator-&gt;get('my_component_factory'); If you see some output different from fatal error you have successfully implemented interop-config. Take a look at the Quick-Start section to see what interop-config can do for you."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/console-tools.html#2-4","title":"Console Tools","content":"Starting in 2.1.0, interop-config began shipping with console tools.To get an overview of available commands run in your CLI .\/vendor\/bin\/interop-config help. This displays the following help message.Usage: command [options] [arguments] Options: -h, --help, help Display this help message Available commands: generate-config Generates options for the provided class name display-config Displays current options for the provided class name "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/console-tools.html#2-4-1","title":"generate-config","content":"The generate-config command is pretty handy. It has never been so easy to create the configuration for a class which uses one of the Interop\\Config interfaces. Depending on implemented interfaces, a wizard will ask you for the option values. It is also possible to update your current configuration. The value in brackets is used, if input is blank.Usage: generate-config [options] [&lt;configFile&gt;] [&lt;className&gt;] Options: -h, --help, help Display this help message Arguments: configFile Path to a config file or php:\/\/stdout for which to generate options. className Name of the class to reflect and for which to generate options. Reads the provided configuration file (creating it if it does not exist), and injects it with options for the provided class name, writing the changes back to the file. If your PHP config file is in the folder config\/global.php and you have a class My\\AwesomeFactory then you run$ .\/vendor\/bin\/interop-config generate-config config\/global.php \"My\\AwesomeFactory\" "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/reference\/console-tools.html#2-4-2","title":"display-config","content":"You can also see which options are set in the configuration file for a factory. If multiple configurations are supported through the Interop\\Config\\RequiresConfigId you can enter a config id or leave it blank to display all configurations.Usage: display-config [options] [&lt;configFile&gt;] [&lt;className&gt;] Options: -h, --help, help Display this help message Arguments: configFile Path to a config file for which to display options. It must return an array \/ ArrayObject. className Name of the class to reflect and for which to display options. Reads the provided configuration file and displays options for the provided class name. If your PHP config file is in the folder config\/global.php and you have a class My\\AwesomeFactory then you run$ .\/vendor\/bin\/interop-config display-config config\/global.php \"My\\AwesomeFactory\" "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1","title":"Contributing","content":"Visit github.com\/sandrokeil\/interop-config\/ for the project website. Make sure you have execute composer install Be sure you are in the root directory "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1-1","title":"Resources","content":"If you wish to contribute to interop-config, please be sure to read to the following resources: Coding Standards: PSR-0\/1\/2\/4 Git Guide: README-GIT.md If you are working on new features, or refactoring an existing component, please create an issue first, so we can discuss it."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1-2","title":"Running tests","content":"To run tests execute phpunit:$ .\/vendor\/bin\/phpunit You can turn on conditional tests with the TestConfig.php file. To do so: Enter the test\/ subdirectory. Copy TestConfig.php.dist file to TestConfig.php Edit TestConfig.php to enable any specific functionality you want to test, as well as to provide test values to utilize. "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1-3","title":"Running PHPCodeSniffer","content":"To check coding standards execute phpcs:$ .\/vendor\/bin\/phpcs To auto fix coding standard issues execute:$ .\/vendor\/bin\/phpcbf "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1-4","title":"Running benchmarks","content":"To run benchmarks execute phpbench:$ .\/vendor\/bin\/phpbench run --report=aggregate "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1-5","title":"Generate documentation","content":"To generate the documentation execute bookdown:$ .\/vendor\/bin\/bookdown doc\/bookdown.json "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/contributing.html#3-1-6","title":"Composer shortcuts","content":"For every program above there are shortcuts defined in the composer.json file. check: Executes PHPCodeSniffer and PHPUnit cs: Executes PHPCodeSniffer cs-fix: Executes PHPCodeSniffer and auto fixes issues test: Executes PHPUnit test-coverage: Executes PHPUnit with code coverage docs: Generates awesome Bookdown.io docs benchmark: Executes PHPBench "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/readme-git.html#3-2-1","title":"Setup your own public GitHub repository","content":"Your first step is to establish a public repository from which you can pull your work into the master repository. Setup a GitHub account, if you haven't yet Fork the interop-config repository Clone your fork locally and enter it (use your own GitHub username in the statement below) $ git clone git@github.com:[your username]\/interop-config.git $ cd interop-config Add a remote to the canonical interop-config repository, so you can keep your fork up-to-date: $ git remote add upstream https:\/\/github.com\/sandrokeil\/interop-config.git $ git fetch upstream "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/readme-git.html#3-2-2","title":"Keeping Up-to-Date","content":"Periodically, you should update your fork to match the canonical interop-config repository. we have added a remote to the interop-config repository, which allows you to do the following:$ git checkout master $ git pull upstream master - OPTIONALLY, to keep your remote up-to-date - $ git push origin If you're tracking other branches -- for example, the develop branch, where new feature development occurs -- you'll want to do the same operations for that branch; simply substitute \"develop\" for \"master\"."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/readme-git.html#3-2-3","title":"Working on interop-config","content":"When working on interop-config, we recommend you do each new feature or bugfix in a new branch. This simplifies the task of code review as well as of merging your changes into the canonical repository.A typical work flow will then consist of the following: Create a new local branch based off your master branch. Switch to your new local branch. (This step can be combined with the previous step with the use of git checkout -b.) Do some work, commit, repeat as necessary. Push the local branch to your remote repository. Send a pull request. The mechanics of this process are actually quite trivial. Below, we will create a branch for fixing an issue in the tracker.$ git checkout -b 3452 Switched to a new branch '3452' ... do some work ...$ git commit ... write your log message ...$ git push origin HEAD:3452 Counting objects: 38, done. Delta compression using up to 2 threads. Compression objects: 100$ (18\/18), done. Writing objects: 100$ (20\/20), 8.19KiB, done. Total 20 (delta 12), reused 0 (delta 0) To ssh:\/\/git@github.com\/sandrokeil\/interop-config.git g5342..9k3532 HEAD -&gt; master You can do the pull request from GitHub. Navigate to your repository, select the branch you just created, and then select the \"Pull Request\" button in the upper right. Select the user sandrokeil as the recipient."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/readme-git.html#3-2-3-1","title":"Branch to issue the pull request","content":"Which branch should you issue a pull request against? For fixes against the stable release, issue the pull request against the master branch. For new features, or fixes that introduce new elements to the public API (such as new public methods or properties), issue the pull request against the develop branch. "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/readme-git.html#3-2-4","title":"Branch Cleanup","content":"As you might imagine, if you are a frequent contributor, you'll start to get a ton of branches both locally and on your remote.Once you know that your changes have been accepted to the master repository, we suggest doing some cleanup of these branches. Local branch cleanup $ git branch -d &lt;branchname&gt; Remote branch removal $ git push origin :&lt;branchname&gt; "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/readme-git.html#3-2-5","title":"Feed and emails","content":"RSS feeds may be found at:https:\/\/github.com\/sandrokeil\/interop-config\/commits\/&lt;branch&gt;.atomwhere &lt;branch&gt; is a branch in the repository.To subscribe to git email notifications, simply watch or fork the interop-config repository on GitHub."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3","title":"Changelog","content":"All notable changes to this project will be documented in this file, in reverse chronological order by release."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-1-1","title":"Added","content":" PHP 8 support "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-1-2","title":"Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-1-3","title":"Removed","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-1-4","title":"Fixed","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-2-1","title":"Added","content":" #36: Create console tools to generate\/display config based on factories. Read more in the docs. Composer suggestion of psr\/container "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-2-2","title":"Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-2-3","title":"Removed","content":" Composer suggestion of container-interop\/container-interop "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-2-4","title":"Fixed","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-3","title":"2.0.1 (2016-12-09)","content":"This release contains no BC break."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-3-1","title":"Added","content":" More test cases for iterable return type and \\Iterator objects "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-3-2","title":"Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-3-3","title":"Removed","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-3-4","title":"Fixed","content":" #34: Inconsistent return type in defaultOptions() defaultOptions() method return type is iterable but array is still valid "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-4","title":"2.0.0 (2016-12-06)","content":"To upgrade from version 1.x to version 2.x you have to add the PHP scalar types of the interfaces to your implemented factory methods."},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-4-1","title":"Added","content":" #33: PHP 7.1 language features (return types, scalar type hints) dimensions() method return type is iterable canRetrieveOptions() method return type is bool mandatoryOptions() method return type is iterable defaultOptions() method return type is array Minor performance improvements More test cases "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-4-2","title":"Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-4-3","title":"Removed","content":" PHP &lt; 7.1 support "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-4-4","title":"Fixed","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-5","title":"1.0.0 (2016-03-05)","content":" This release contains BC breaks, but upgrade path is simple. "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-5-1","title":"Added","content":" #26: dimensions() method to RequiresConfig to make configuration depth flexible "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-5-2","title":"Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-5-3","title":"Removed","content":" #26: vendorName() and packageName() method from RequiresConfig, replaced by dimensions() method It's recommended to remove the methods and use the values directly in dimensions() to increase performance public function dimensions() { return [$this-&gt;vendorName(), $this-&gt;packageName()]; } #26: RequiresContainerId interface is renamed to RequiresConfigId use the container id as a second argument by options() method. "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-5-4","title":"Fixed","content":" #28: Throws exception if dimensions are set but default options are available and no mandatory options configured "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-6-1","title":"Added","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-6-2","title":"Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-6-3","title":"Removed","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-6-4","title":"Fixed","content":" Fixed Illegal offset type in isset or empty if options are empty and recursive mandatory options are used "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-7-1","title":"Added","content":" #9: Introducing ProvidesDefaultOptions interface #13: Support for recursive mandatory options check canRetrieveOptions() to ConfigurationTrait to perform the options check without throwing an exception optionsWithFallback() to ConfigurationTrait which uses default options if config can not be retrieved OptionNotFoundException and MandatoryOptionNotFoundException extends OutOfBoundsException instead of RuntimeException Check if retrieved options are an array or an instance of ArrayAccess Benchmark suite Updated documentation "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-7-2","title":"Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-7-3","title":"Removed","content":" HasConfig interface, was renamed to RequiresConfig HasContainer interface, was renamed to RequiresContainerId HasMandatoryOptions interface, was renamed to RequiresMandatoryOptions HasDefaultOptions interface, was renamed to ProvidesDefaultOptions ObtainsOptions interface, was merged in RequiresConfig OptionalOptions interface, can be achieved via ProvidesDefaultOptions "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-7-4","title":"Fixed","content":" fixed wrong function name in documentation "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-8-1","title":"Added","content":" #5: replaced componentName function with packageName (PSR-4 standard) "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-8-2","title":"Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-8-3","title":"Removed","content":" #5: componentName function from HasConfig interface (BC break) "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-8-4","title":"Fixed","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-9-1","title":"Added","content":" Initial release Added interfaces #2: Added trait implementation "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-9-2","title":"Deprecated","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-9-3","title":"Removed","content":" Nothing "},{"id":"https:\/\/sandrokeil.github.io\/interop-config\/contribute\/changelog.html#3-3-9-4","title":"Fixed","content":" Nothing "}]